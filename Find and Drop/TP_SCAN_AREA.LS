/PROG  TP_SCAN_AREA
/ATTR
OWNER		= MNEDITOR;
COMMENT		= "";
PROG_SIZE	= 1474;
CREATE		= DATE 23-02-13  TIME 14:59:52;
MODIFIED	= DATE 23-04-12  TIME 14:04:08;
FILE_NAME	= TP_SCAN_;
VERSION		= 0;
LINE_COUNT	= 86;
MEMORY_SIZE	= 1890;
PROTECT		= READ_WRITE;
TCD:  STACK_SIZE	= 0,
      TASK_PRIORITY	= 50,
      TIME_SLICE	= 0,
      BUSY_LAMP_OFF	= 0,
      ABORT_REQUEST	= 0,
      PAUSE_REQUEST	= 0;
DEFAULT_GROUP	= 1,*,*,*,*;
CONTROL_CODE	= 00000000 00000000;
/APPL
/MN
    : ! TP_SCAN_AREA is a program to scan a rectangular area with the vision system;
    : ! and to find the positions of the objects in a given area;
   1:  UFRAME_NUM=3 ;
   2:  UTOOL_NUM=1 ;
   3:  PAYLOAD[1] ;
   4:  OVERRIDE=15% ;
   5:   ;
    :  !Reset all the values of the registers;
   6:  R[14]=0    ;
   7:  R[15]=0    ;
   8:  R[16]=0    ;
   9:  R[25]=0    ;
  10:  R[26]=0    ;
  11:  R[27]=0    ;
  12:  R[28]=0    ;
  13:  R[29]=0    ;
  14:  R[32]=0    ;
    :  !Start the loop program;
  15:  LBL[1] ;
  16:  R[1]=0    ;
  17:   ;
  18:J PR[30] 25% FINE    ;
  19:   ;
  20:  FOR R[1]=1 TO R[21] ;
  21:  R[30]=R[1]+24    ;
  22:  IF (R[R[30]]=1 AND R[32]<=R[21]) THEN ;
  23:  JMP LBL[90] ;
  24:  ENDIF ;
  25:  R[6]=9+R[1]    ;
  26:  SR[25]=SR[R[6]]    ;
  27:   ;
    :  ! Use iRvision to find the position of the object name contained in SR[25];
  28:  VISION RUN_FIND SR[25]    ;
    :  ! Get the offset of the object and store it in VR[R[1]] (R[1] is the counter of the loop);
    :  ! If the object is not found, then jump to LBL[90];
  29:  VISION GET_OFFSET SR[25] VR[R[1]] JMP LBL[90] ;
  30:   ;
    :  ! If object is found and the DO[120] is ON, then turn on the DO[105] sounding a buzzer;
  31:  IF (DO[120]),DO[105]=(ON) ;
    :  !---------------------------------------------------------------------------------------;
    :  !------------------------------------Scanning-------------------------------------------;
    :  !-------------------------- X ----------------------------------------------------------;
    :  !------ Start scanning here |  |-> -> -> -> -> -> -> -> ->|    ends here ---------------;
    :  !---------------- ends here |  |<- <- <- <- <- <- <- <- <-|    continue scanning here---;
    :  !-- continues scanning here |  |-> -> -> -> -> -> -> -> ->|    ends here ---------------;
    :  !---------------- ends here |  |<- <- <- <- <- <- <- <- <-|    continue scanning here---;
    :  !---------------------------|_____________________________ Y ---------------------------;
    :  !---------------------------------------------------------------------------------------;
    :  !This code bellow scans for objects, on top we have an example of what I'm trying to do ;
    :  !For more information about this code, look at TP_PLC_SCAN it contains the same logic.--;
    :  !-The only diference is that this subprogram was improve to save time.------------------;
  32:  R[5]=1    ;
  33:  R[R[30]]=1    ;
  34:  R[32]=R[32]+1    ;
  35:  WAIT    .30(sec) ;
  36:  DO[105]=OFF ;
  37:  IF R[32]>=R[21],JMP LBL[99] ;
  38:  LBL[90] ;
  39:  ENDFOR ;
  40:  IF (R[1]>R[21]) THEN ;
  41:  JMP LBL[97] ;
  42:  ENDIF ;
  43:   ;
  44:  LBL[97] ;
  45:  IF (R[15]<=0) THEN ;
  46:  R[15]=1    ;
  47:  R[14]=1    ;
  48:  JMP LBL[2] ;
  49:  ENDIF ;
  50:   ;
  51:  IF (R[15]>R[19]) THEN ;
  52:  R[15]=R[19]    ;
  53:  R[14]=0    ;
  54:  JMP LBL[2] ;
  55:  ELSE ;
  56:  JMP LBL[3] ;
  57:  ENDIF ;
  58:   ;
  59:  LBL[2] ;
  60:  IF (R[16]>R[20]) THEN ;
  61:  R[5]=0    ;
  62:   ;
  63:  JMP LBL[99] ;
  64:  ELSE ;
  65:  R[16]=R[16]+1    ;
  66:  PR[30]=PR[30]+PR[42]+PR[42]    ;
  67:  JMP LBL[1] ;
  68:  ENDIF ;
  69:   ;
  70:  LBL[3] ;
  71:  IF (R[14]=0) THEN ;
  72:  R[15]=(R[15]-1) ;
  73:   ;
  74:  PR[30]=PR[30]-PR[41]-PR[41]    ;
  75:   ;
  76:  JMP LBL[1] ;
  77:  ELSE ;
  78:  R[15]=(R[15]+1) ;
  79:   ;
  80:  PR[30]=PR[30]+PR[41]+PR[41]    ;
  81:   ;
  82:  JMP LBL[1] ;
  83:  ENDIF ;
  84:   ;
  85:   ;
  86:  LBL[99] ;
/POS
/END
